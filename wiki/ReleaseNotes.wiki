#summary notes on changes between releases
#labels Featured

*See the AtomBeat wiki page for information on downloading and/or building AtomBeat.*

<wiki:toc/>

= 0.2-alpha-6-SNAPSHOT =

== issue 123 auto-categorise feature ==

In this release AtomBeat implements support for the app:categories element within collection definitions. The [http://www.atomenabled.org/developers/protocol/atom-protocol-spec.php#categories-elem Atom protocol spec] is a bit vague on how exactly this should work, so AtomBeat's behaviour is as follows. 

If an app:collection contains an app:categories element where the @fixed='yes' but there is no @scheme attribute, then any category in an Atom entry not within the given list is stripped automatically on create or update.

If an app:collection contains an app:categories element where the @fixed='yes' and there *is* a @scheme attribute, then any category in an Atom entry *with the given scheme* but not within the given list is stripped automatically on create or update. Any categories in a different scheme are allowed to remain. This enables collections to specify control of categories within a given scheme but also allow uncontrolled use of categories from other schemes.

AtomBeat also supports an extension attribute @default on at most one atom:category element within an app:categories element. The default category will be automatically added if no categories match the given list.

E.g., a collection defined like:

{{{
<app:collection xmlns:app='http://www.w3.org/2007/app' href='http://localhost:8081/atombeat/service/content/test'>
  <app:categories scheme='http://example.org/scheme' fixed='yes'>
    <atom:category term='foo' label='Foo'/>
    <atom:category term='bar' label='Bar' default='yes'/>
  </app:categories>
</app:collection>
}}}

...will mean that any member of the collection must contain one category with scheme http://example.org/scheme from the given list (either 'foo' or 'bar). Any categories with scheme http://example.org/scheme but not in this list will be stripped automatically. If no categories from this list are given, the default category ('bar') will be automatically added. Categories in schemes other than http://example.org/scheme will be uncontrolled, i.e., clients are free to do what they want.

== issue 151 service links ==

Atom entries and feeds now include an atom:link with rel='service' pointing to the service document location.

== issue 150 use slug to allow client preference for member uri ==

In this release the "Slug" request header can be used when POSTing an Atom entry document to a collection URI to indicate a client preference for the URI of the new collection member to be created. 

E.g., if the header "Slug: foo" is included in a request to create a new member in the http://localhost:8081/atombeat/service/content/test collection, then the URI of the new member will be http://localhost:8081/atombeat/service/content/test/foo - if no member at that URI already exists. If a member does already exist at that URI, AtomBeat will try foo1, foo2 ... foo5, and then fall back to using the `config:generate-identifier()` function as if no Slug header were present.

== issue 141 conneg for service documents ==

Content negotiation can now be configured for the Atom service document. Transformations to HTML and JSON are supported in the default configuration, and additional variants can be configured in a similar way to configuration of content negotiation for Atom feeds and entries.

To upgrade to this release two additional configuration variables need to be added to the `config/conneg.xqm` configuration file. These are `$conneg-config:service-variants` and `$conneg-config:service-transformers`. An example configuration from the default configuration is given below:

{{{
xquery version "1.0";

module namespace conneg-config = "http://purl.org/atombeat/xquery/conneg-config";

...

(:~
 : Define variant representations for service document.
 :)
declare variable $conneg-config:service-variants := 
    <variants>
        <variant>
            <output-key>html</output-key>
            <media-type>text/html</media-type>
            <output-type>xml</output-type>
            <doctype-public>-//W3C//DTD&#160;XHTML&#160;1.0&#160;Strict//EN</doctype-public>
            <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
            <qs>0.95</qs>
        </variant>
        <variant>
            <output-key>atomsvc</output-key>
            <media-type>application/atomsvc+xml</media-type>
            <output-type>xml</output-type>
            <qs>0.8</qs>
        </variant>
        <variant>
            <output-key>json</output-key>
            <media-type>application/json</media-type>
            <output-type>text</output-type>
            <qs>0.5</qs>
        </variant>
        <variant>
            <output-key>xml</output-key>
            <media-type>application/xml</media-type>
            <output-type>xml</output-type>
            <qs>0.3</qs>
        </variant>
        <variant>
            <output-key>textxml</output-key>
            <media-type>text/xml</media-type>
            <output-type>xml</output-type>
            <qs>0.2</qs>
        </variant>
        <variant>
            <output-key>text</output-key>
            <media-type>text/plain</media-type>
            <output-type>xml</output-type>
            <qs>0.1</qs>
        </variant>
    </variants>
;



(:~
 : Define transformers for variant representations. There MUST be one transformer
 : for each variant, and they must occur in the same position within the sequence
 : as the corresponding variant definition above.
 :)
declare variable $conneg-config:service-transformers := (
    <stylesheet>/stylesheets/atomsvc2html4.xslt</stylesheet> , (: if not absolute URI will be concatenated with $config:service-url-base :)
    <identity/> ,
    util:function( QName( "http://purl.org/atombeat/xquery/json" , "json:xml-to-json" ) , 1 ) , (: if you use a function as a transformer, then the function's module MUST be imported into this module, see imports at the top of this file :)
    <identity/> ,
    <identity/> ,
    <identity/> 
);
}}}

== issue 137 link from service document to workspace security descriptor ==

The service document in a security-enabled AtomBeat service now includes a link from within the singleton `<app:workspace>` element to the workspace security descriptor.

== issue 120 filter service documents using permissions ==

In a security-enabled AtomBeat service, service documents will now be filtered to include only `<app:collection>` elements where the requesting user is allowed to list that collection.

== issue 152 access control for service documents ==

In security-enabled AtomBeat service, retrieval of service documents can now be controlled via access control lists. The new operation name RETRIEVE_SERVICE can be used in access control entries to allow or deny access to the service document.

Note that this feature has been implemented by passing the RETRIEVE_SERVICE operation through the plugin functions. I.e., any plugin functions can now intercept the RETRIEVE_SERVICE operation and execute side-effects and/or transform the response.

== issue 149 cannot use atom-protocol:do-`*` from within xquery as headers from host page are interpreted as headers in nested request ==

The signature of all plugin functions has been changed, to provide better support for calling the [http://code.google.com/p/atombeat/source/browse/trunk/parent/atombeat-service/src/main/files/lib/atom-protocol.xqm Atom protocol library functions] (e.g., `atom-protocol:do-post-atom-entry()`) programmatically from within other XQueries. 

Plugins in the *before* chain now must have the following signature:

{{{
declare function example-plugin:before(
    $operation as xs:string ,
    $request as element(request) ,
    $entity as item()*
) as item()*
{

    (: any side-effects :)	
    let $modified-entity := ... (: transform the request entity, if desired :)
    return $modified-entity
    
};
}}}

The `$operation` argument is the name of the protocol operation being executed, as in previous versions.

The `$request` argument is an XML fragment representing the HTTP request being executed. It has the general form:

{{{
<request>
    <path-info>/test/xyz</path-info>
    <method>POST</method>
    <headers>
        <header>
            <name>Accept</name>
            <value>application/atom+xml</value>
        </header>
        <header>
            <name>Content-Type</name>
            <value>application/atom+xml</value>
        </header>
    </headers>
    <parameters>
        <parameter>
            <name>foo</name>
            <value>bar</value>
        </parameter>
    </parameters>
    <user>someone@example.org</user>
    <roles>
        <role>ROLE_FOO</role>
    </roles>
</request>
}}}

So, whereas previously $request-path-info was supplied as a function argument, now the path-info can be accessed (along with other features of the request) via the $request argument, e.g.:

{{{
    let $request-path-info := $request/path-info/text()
}}}

The `$entity` argument is the request payload, if available. This will also be empty in the case of media operations, as media payloads may be streamed directly from the context request.

The return type of *before* plugins is not changed. Either the request entity is returned, possibly with modifications, in which case request processing will continue, or a `<response>` element is returned, in which case request processing will terminate and a response be sent immediately.

Plugins in the *after* chain now must have the following signature:

{{{
declare function logger-plugin:after(
	$operation as xs:string ,
	$request as element(request) ,
	$response as element(response)
) as element(response)
{

    (: any side-effects :)	
    let $modified-response := ... (: modify the response, if desired :)
    return $modified-response

}; 
}}}

The `$operation` and `$request` arguments are as described above for the *before* plugins. The `$response` argument is as in previous versions. The return type is as in previous versions, being an XML fragment representing the response, either unmodified or with modifications if desired.

*Plugin functions in either before or after chains should now access request headers and parameters via the $request variable, and should not call `request:get-header()` or `request:get-parameter()` directly, as this can lead to confusion and incorrect behaviour when an Atom protocol library function such as `atom-protocol:do-post-atom-entry()` is called programmatically from another XQuery.*

For convenience, the xutil module has some functions for accessing request headers and parameters, e.g.:

{{{
    let $content-type-header := xutil:get-header( "Content-Type" , $request )
    let $foo-parameter := xutil:get-parameter( "foo" , $request )
}}}

Because the number of arguments supplied to plugin functions in the *before* chain has changed from 4 to 3, the plugin configuration file (`config/plugins.xqm`) will need to be changed accordingly, e.g.:

{{{
declare function plugin:before() as function* {
    (
        util:function( QName( "http://purl.org/atombeat/xquery/logger-plugin" , "logger-plugin:before" ) , 3 ) ,
        util:function( QName( "http://purl.org/atombeat/xquery/security-plugin" , "security-plugin:before" ) , 3 ) , 
        util:function( QName( "http://purl.org/atombeat/xquery/conneg-plugin" , "conneg-plugin:before" ) , 3 ) , 
        util:function( QName( "http://purl.org/atombeat/xquery/tombstones-plugin" , "tombstones-plugin:before" ) , 3 ) ,  
       	util:function( QName( "http://purl.org/atombeat/xquery/link-expansion-plugin" , "link-expansion-plugin:before" ) , 3 ) ,  
        util:function( QName( "http://purl.org/atombeat/xquery/link-extensions-plugin" , "link-extensions-plugin:before" ) , 3 ) ,  
        util:function( QName( "http://purl.org/atombeat/xquery/history-plugin" , "history-plugin:before" ) , 3 )   
    )
};
}}}

The number of arguments supplied to plugin functions in the *after* chain has not changed.

The upshot of all this is that now it should be safe to write XQueries that do things like combining multiple virtual Atom protocol requests, e.g. (trivial example, hopefully you get the general idea):

{{{
declare namespace atom = "http://www.w3.org/2005/Atom" ;
import module namespace atom-protocol = "http://purl.org/atombeat/xquery/atom-protocol" at "../lib/atom-protocol.xqm" ;

let $request1 :=
    <request>
        <path-info>/foo</path-info>
        <method>POST</method>
        <headers>
            <header>
                <name>Accept</name>
                <value>application/atom+xml</value>
            </header>
            <header>
                <name>Content-Type</name>
                <value>application/atom+xml</value>
            </header>
        </headers>
        <parameters/>
        <user>someone@example.org</user>
        <roles/>
    </request>

let $entity1 :=
    <atom:entry>
        <atom:title>foo entry</atom:title>
    </atom:entry>
    
let $response1 := atom-protocol:do-post-atom-entry( $request1 , $entity1 ) (: will perform protocol operation including plugin execution :)

return

    if ( $response1/status = 201 ) then
    
        let $request2 :=
            <request>
                <path-info>/bar</path-info>
                <method>POST</method>
                <headers>
                    <header>
                        <name>Accept</name>
                        <value>application/atom+xml</value>
                    </header>
                    <header>
                        <name>Content-Type</name>
                        <value>application/atom+xml</value>
                    </header>
                </headers>
                <parameters/>
                <user>someone@example.org</user>
                <roles/>
            </request>

        let $entity2 :=
            <atom:entry>
                <atom:title>bar entry</atom:title>
                <atom:link rel='related' href='{$response1/body/atom:entry/atom:link[@rel="edit"]/@href cast as xs:string}'/>
            </atom:entry>
            
        let $response2 := atom-protocol:do-post-atom-entry( $request2 , $entity2 ) (: will perform protocol operation including plugin execution :)

        return
                
            if ( $response2/status = 201 ) then ... (: handle success :)
                
            else ... (: handle failure after second sub-request :)
    
    else ... (: handle failure after first sub-request :)
}}}

Another example of an XQuery that makes use of this pattern is the [http://code.google.com/p/atombeat/source/browse/trunk/parent/atombeat-service/src/main/files/admin/install.xql admin/install.xql] page.

Please note that *not all functions in the [http://code.google.com/p/atombeat/source/browse/trunk/parent/atombeat-service/src/main/files/lib/atom-protocol.xqm atom-protocol XQuery module] can be called in this way*. Some functions, in particular those processing media content, need to access the context request, and thus can only be used via direct HTTP request to the /service/content endpoint. Those functions that *can* safely be called from within another XQuery include:

  * atom-protocol:do-get-member()
  * atom-protocol:do-get-collection()
  * atom-protocol:do-post-atom()
  * atom-protocol:do-post-atom-entry()
  * atom-protocol:do-post-atom-feed()
  * atom-protocol:do-put-atom()
  * atom-protocol:do-put-atom-entry()
  * atom-protocol:do-put-atom-feed()
  * atom-protocol:do-delete-member()
  * atom-protocol:do-delete-media()

= 0.2-alpha-5 =

== issue 140 make json output consistent using element local names instead of qnames ==

The function used to transform from Atom XML to JSON in the default content negotiation plugin configuration has been changed to use a slightly tweaked version of the XML-to-JSON function that comes with eXist. The tweak is to use element local names to generate JSON object keys instead of node names, which means that clients asking for JSON won't get confused by inconsistent use of namespace prefixes in the source Atom XML document.

E.g., an Atom entry document like:

{{{
<atom:entry xmlns:atom="http://www.w3.org/2005/Atom">
    <atom:id>urn:uuid:0b7c7ded-0eaf-43ca-84ac-7de93ad7f636</atom:id>
    <atom:published>2011-02-01T11:24:42.81Z</atom:published>
    <atom:updated>2011-02-01T11:24:42.81Z</atom:updated>
    <atom:author>
        <atom:name>adam</atom:name>
    </atom:author>
    <title xmlns="http://www.w3.org/2005/Atom" type="text">testing json representstation</title>
    <summary xmlns="http://www.w3.org/2005/Atom" type="text">this is a test to check that element local names are used in json representation</summary>
    <atom:link rel="edit" type="application/atom+xml;type=entry" href="http://localhost:8081/atombeat-exist-minimal-secure/service/content/test/0b7c7ded-0eaf-43ca-84ac-7de93ad7f636"/>
    <atom:link rel="alternate" type="application/atom+xml" href="http://localhost:8081/atombeat-exist-minimal-secure/service/content/test/0b7c7ded-0eaf-43ca-84ac-7de93ad7f636?output=atom"/>
    <atom:link rel="alternate" type="application/json" href="http://localhost:8081/atombeat-exist-minimal-secure/service/content/test/0b7c7ded-0eaf-43ca-84ac-7de93ad7f636?output=json"/>
</atom:entry>
}}}

...gets transformed to JSON like:

{{{
{
  "id" : "urn:uuid:0b7c7ded-0eaf-43ca-84ac-7de93ad7f636", 
  "published" : "2011-02-01T11:24:42.81Z", 
  "updated" : "2011-02-01T11:24:42.81Z", 
  "author" : {
    "name" : "adam"
  }, 
  "title" : {
    "@type": "text", 
    "#text": "testing json representstation"
  }, 
  "summary" : {
    "@type": "text", 
    "#text": "this is a test to check that element local names are used in json representation"
  }, 
  "link" : [ 
    {
      "@rel": "edit", 
      "@type": "application/atom+xml;type=entry", 
      "@href": "http://localhost:8081/atombeat-exist-minimal-secure/service/content/test/0b7c7ded-0eaf-43ca-84ac-7de93ad7f636"
    }, 
    {
      "@rel": "alternate", 
      "@type": "application/atom+xml", 
      "@href": "http://localhost:8081/atombeat-exist-minimal-secure/service/content/test/0b7c7ded-0eaf-43ca-84ac-7de93ad7f636?output=atom"
    }, 
    {
      "@rel": "alternate", 
      "@type": "application/json", 
      "@href": "http://localhost:8081/atombeat-exist-minimal-secure/service/content/test/0b7c7ded-0eaf-43ca-84ac-7de93ad7f636?output=json"
    }, 
  ]
}
}}}

== issue 139 conneg plugin doesn't strip alternate links prior to create or update ==

This is a bug fix in the content negotiation plugin.

== issue 57 configurable conneg plugin ==

This release includes a new content negotiation (conneg) plugin, that allows you to request and serve Atom feeds and entries in variant representation formats, including HTML and JSON. The plugin implements [http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html server-driven content negotation] based on the values provided in the Accept request header. The plugin also adds `alternate` links to entries and feeds, so you can use these links to retrieve a specific representation format if you need to without having to provide an `Accept` header.

To enable the conneg plugin, the [http://code.google.com/p/atombeat/source/browse/trunk/parent/atombeat-service/src/main/files/config/plugins.xqm config/plugins.xqm] file needs to be modified, to include the conneg plugin before and after functions in the respective plugin chains.

The plugin configuration is defined in the [http://code.google.com/p/atombeat/source/browse/trunk/parent/atombeat-service/src/main/files/config/conneg.xqm config/conneg.xqm] file. A [http://code.google.com/p/atombeat/source/browse/trunk/parent/atombeat-service/src/main/files/config/conneg.xqm default version] of this file is included in all AtomBeat WAR packages.

This default configuration supports content negotiation to HTML and JSON formats out of the box. If you want to add additional variant formats, you need to implement either an XSLT transformation or an XQuery function to transform from Atom to the new format, then modify the `$conneg-config:variants` and `$conneg-config:transformers` variables. Note that these two variables need to be kept consistent with each other, i.e., the ordering of variants must correspond to the ordering of transformers.

The server-driven content negotiation algorithm implemented in AtomBeat is close to that implemented in Apache, see also the [http://httpd.apache.org/docs/current/content-negotiation.html#methods Apache content negotiation documentation].

= 0.2-alpha-4 =

== issue 81 reference groups where source is any atom member ==

The way that out-of-line security groups are referenced from a security descriptor has changed. In this release, you can either reference a security group defined in another security descriptor, *or* you can reference a group defined in an Atom collection member. 

To reference a group defined in a security descriptor, use the *security descriptor URI* in the `@src` attribute. E.g.:

{{{
<atombeat:security-descriptor>
     <atombeat:groups>
         <atombeat:group id="admins" src="http://example.org/atombeat/service/security/mycollection/mymember"/>
     </atombeat:groups>
     <atombeat:acl>
     </atombeat:acl>
 </atombeat:security-descriptor>
}}}

To reference a group defined in an Atom collection member, use the *member's edit URI* in the `@src` attribute.

{{{
<atombeat:security-descriptor>
     <atombeat:groups>
         <atombeat:group id="admins" src="http://example.org/atombeat/service/content/mycollection/mymember"/>
     </atombeat:groups>
     <atombeat:acl>
     </atombeat:acl>
 </atombeat:security-descriptor>
}}}

The definition of a group can appear *anywhere* within the member's Atom entry document. I.e., AtomBeat will use the XPath `//atombeat:group[@id='admins']` to find matching groups within the referenced document.

In previous releases, you could only reference groups defined in a security descriptor, and this was done indirectly *via* the URI of the workspace, collection or member whose descriptor you wanted to reference. Upgrading to this release will require that any URIs given in `@src` attributes on `atombeat:group` elements are *changed* to point *directly* to the URI of the security descriptor containing the group definitions.

= 0.2-alpha-3 =

== issue 130 remove references to request from atomdb xquery module ==

The signature of the following functions has changed:

  * atomdb:create-entry
  * atomdb:create-media-link-entry
  * atomdb:create-feed
  * atomdb:create-member
  * atomdb:create-media-resource
  * atomdb:create-collection
  * atomdb:create-file-backed-media-resource-from-request-data
  * atomdb:create-file-backed-media-resource-from-existing-media-resource
  * atomdb:create-file-backed-media-resource-from-upload
  
An additional parameter `$user-name` has been added to the function signature, to remove some of the dependencies of the `lib/atomdb.xqm` module on the eXist request function module. This change has been made to make testing the `lib/atomdb.xqm` functions easier.

Upgrading to this release will require any custom XQuery modules that call any of the above functions to be modified to use the new function signature.
  
== issue 129 make atom:id construction configurable ==

A new configuration function `config:construct-member-atom-id()` has been added to the `config/shared.xqm` configuration module. This new function allows customisation of the way in which `atom:id` elements are populated for new collection members.

Upgrading to this release will require this function to be implemented in the `config/shared.xql` configuration module.

If you are using UUIDs as the basis for member identifiers, then you have the option to use UUID URNs for atom:id elements. E.g.,:

{{{
declare function config:generate-identifier(
    $collection-path-info as xs:string
) as xs:string
{
    util:uuid()
};

declare function config:contruct-member-atom-id(
    $identifier as xs:string ,
    $collection-path-info as xs:string
) as xs:string
{
    concat( 'urn:uuid:' , $identifier )
};
}}}

The $identifier parameter passed into this function is obtained from calling the config:generate-identifier() function.

Alternatively, e.g., if you were using shorter identifiers that are not guaranteed to be unique across collections, you could do something like the following:

{{{
declare function config:generate-identifier(
    $collection-path-info as xs:string
) as xs:string
{
    xutil:random-alphanumeric( 6 )
};

declare function config:contruct-member-atom-id(
    $identifier as xs:string ,
    $collection-path-info as xs:string
) as xs:string
{
    concat( $config:self-link-uri-base , $collection-path-info , $identifier )
};
}}} 

== issue 118	implement md5 in @hash link extension attribute for media-link entries ==

If the FILE media storage mode is being used, an MD5 hash will automatically be calculated for every new and updated media resource, and the hash value will be added to the associated media-link entry in a @hash attribute on both the 'edit-media' link and the atom:content element.

This is a backwards compatible change, in that upgrading to this release does not require any migration of the data. However, note that media-link entries created prior to upgrade will not include a @hash attribute. 

== issue 114 configure self link uri base independently from edit uri base ==

The way in which the URI base for 'self', 'edit' and 'edit-media' links is configured has changed. The variable $config:content-service-url in the config/shared.xqm configuration module has been removed. Three new variables have been added in it's place, being $config:self-link-uri-base, $config:edit-link-uri-base and $config:edit-media-link-uri-base. These new variables allow URI bases for different link types to be configured independently if desired.

Upgrading to this release will require modification of the config/shared.xqm to use the new configuration variables.

= 0.2-alpha-2 =

TODO document me complete release notes for this version

== issue 24 provide service documents ==

This release implements Atom Protocol service documents. E.g., if an !AtomBeat service is located at at http://example.org/atombeat/service/ then a GET request to this URI will return an Atom Protocol service document listing available Atom collections.

The title and summary given in the atom:workspace element in the service document are configured using two new variables in the config/shared.xqm configuration module, being $config:workspace-title and $config:workspace-summary.

Upgrading to this release will require modification of the config/shared.xqm to use the new configuration variables.

Note also that collections created prior to upgrading to this release will not initially appear in the service document. They will appear after an update to the collection feed metadata, i.e., after a PUT to the collection URI. 

== issue 97 remove ".atom" from the end of member URIs ==

In this release the string ".atom" is no longer appending to member URIs. 

This is a major change, and requires that all member URIs present in the database prior to upgrade, e.g., in Atom entry documents, need to be modified following an upgrade to have the ".atom" suffix removed.

Note however that the documents stored in the eXist database still retain the ".atom" suffix, i.e., the documents themselves don't need to be moved.

== issue 99 TODO document me ==

== issue 104 TODO document me ==

== issue 105 TODO document me ==

== issue 106 migrate workspace to service ==

The default location for the !AtomBeat service in all WAR packages has changed from /workspace to /service. 

All !AtomBeat URIs for resources (collections, members, media) created prior to upgrade will need to be modified to reflect the new URL base.

== issue 111 upgrade to spring security 3.1 ==

Spring Security in secure WAR packages has been upgraded to 3.1.0.M1.

== issue 112 TODO document me ==

== issue 116 TODO document me ==

= 0.2-alpha-1 =

== issue 98 implement tombstones ==

TODO document me

== issue 100 error plugins ==

TODO document me
